<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2020.2 (Released July 1, 2020) -->
<HTML lang="en">
<HEAD>
<TITLE>8.3 Retargetting for other Processors</TITLE>
<META NAME="description" CONTENT="8.3 Retargetting for other Processors">
<META NAME="keywords" CONTENT="sdccman">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2020.2">

<LINK REL="STYLESHEET" HREF="sdccman.css">

<LINK REL="previous" HREF="node212.html">
<LINK REL="next" HREF="node214.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node214.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node194.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node212.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html2158"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html2160"
  HREF="node219.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node214.html">9. Compiler internals</A>
<B> Up:</B> <A
 HREF="node194.html">8. SDCC Technical Data</A>
<B> Previous:</B> <A
 HREF="node212.html">8.2 Cyclomatic Complexity</A>
 &nbsp; <B>  <A ID="tex2html2159"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html2161"
  HREF="node219.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H1><A ID="SECTION00930000000000000000">
<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">3</SPAN> Retargetting for other Processors</A>
</H1>

<P>
The issues for retargetting the compiler are far too numerous to be
covered by this document. What follows is a brief description of each
of the phases of the compiler and its MCU dependency.

<UL>
<LI>Parsing the source and building the annotated parse tree. This phase
is largely MCU independent (except for the language extensions). Syntax
&amp; semantic checks are also done in this phase, along with some initial
optimizations like back patching labels and the pattern matching optimizations
like bit-rotation etc.
</LI>
<LI>The second phase involves generating an intermediate code which can
be easy manipulated during the later phases. This phase is entirely
MCU independent. The intermediate code generation assumes the target
machine has unlimited number of registers, and designates them with
the name iTemp. The compiler can be made to dump a human readable
form of the code generated by using the &mdash;dumpraw option.
</LI>
<LI>This phase does the bulk of the standard optimizations and is also
MCU independent. This phase can be broken down into several sub-phases:
<BR>
<BR>
Break down intermediate code (iCode) into basic blocks.
<BR>
Do control flow &amp; data flow analysis on the basic blocks.
<BR>
Do local common subexpression elimination, then global subexpression
elimination
<BR>
Dead code elimination
<BR>
Loop optimizations
<BR>
If loop optimizations caused any changes then do 'global subexpression
elimination' and 'dead code elimination' again.
</LI>
<LI>This phase determines the live-ranges; by live range I mean those
iTemp variables defined by the compiler that still survive after all
the optimizations. Live range analysis<A NAME="4452"></A>
is essential for register allocation, since these computation determines
which of these iTemps will be assigned to registers, and for how long.
</LI>
<LI>Phase five is register allocation. For new ports register allocator
described above in <A HREF="node210.html#subsec:Register-Allocation">8.1.15</A> should be used
in most cases, since it can result in substantially better code. In
the old register allocator, there are two parts to register allocation.
<BR>
<BR>
The first part I call 'register packing' (for lack of a better term).
In this case several MCU specific expression folding is done to reduce
register pressure.
<BR>
<BR>
The second part is more MCU independent and deals with allocating
registers to the remaining live ranges. A lot of MCU specific code
does creep into this phase because of the limited number of index
registers available in the 8051.
</LI>
<LI>The Code generation phase is (unhappily), entirely MCU dependent and
very little (if any at all) of this code can be reused for other MCU.
However the scheme for allocating a homogenized assembler operand
for each iCode operand may be reused.
</LI>
<LI>As mentioned in the optimization section the peep-hole optimizer is
rule based system, which can reprogrammed for other MCUs.
</LI>
</UL>
More information is available on SDCC Wiki<A NAME="4455"></A> (preliminary
link <kbd><A ID="tex2html145"
  HREF="http://sdcc.sourceforge.net/wiki/index.php/SDCC_internals_and_porting">http://sdcc.sourceforge.net/wiki/index.php/SDCC_internals_and_porting</A></kbd>)
and in the thread <kbd><A ID="tex2html146"
  HREF="http://sourceforge.net/mailarchive/message.php?msg_id=13954144">http://sourceforge.net/mailarchive/message.php?msg_id=13954144</A></kbd>.

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node214.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node194.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node212.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html2158"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html2160"
  HREF="node219.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node214.html">9. Compiler internals</A>
<B> Up:</B> <A
 HREF="node194.html">8. SDCC Technical Data</A>
<B> Previous:</B> <A
 HREF="node212.html">8.2 Cyclomatic Complexity</A>
 &nbsp; <B>  <A ID="tex2html2159"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html2161"
  HREF="node219.html">Index</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
